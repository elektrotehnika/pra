# ПРА: вежбе - linux - скриптовање - белешке

<br>

Садржаји су углавном преузети из књиге [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1), биће назначено о којој се области ради. Биће излистани одабрани садржаји са примерима ради лакше навигације.

<br>

## Манипулација називима фајлова

<br>

Област 4 - _Wildcards_ && Област 7 - _Pathname\_expansion_

* \* - мења било који (низ) карактер**А**,
* ? - мења било који карактер,
* [скуп] - мења било који карактер који припада задатом скупу, скуп може бити кориснички дефинисан, или постојећи, односно предефинисан,
* [!скуп] - мења било који карактер који **не** припада скупу,
* [[:класа:]] - мења било који карактер који припада наведеној класи, примери за класе јесу:
  * [:alnum:] - мења било који алфанумерички карактер (слова или бројеви),
  * [:alpha:] - мења било које слово,
  * [:digit:] - мења било коју цифру/број,
  * [:lower:] - мења било које мало слово,
  * [:upper:] - мења било које велико слово.

<br>

<details markdown='block'>
<summary>Примери </summary>

```bash
echo * # излистава све фајлове који се налазе у тренутном радном директоријуму
```

```bash
echo [abc]* # излистава све фајлове који се налазе у тренутном радном директоријуму и чији назив почиње или малим словом а, или б, или ц 
```

```bash
echo primer?.txt # излистава све фајлове који се налазе у тренутном радном директоријуму и који у свом називу имају реч primer праћену тачно једним карактером (рецимо број, нумерација; али може бити било који карактер), а потом и екстензију .txt
```

```bash
echo primer[0-9].txt # излистава све фајлове који се налазе у тренутном радном директоријуму и који у свом називу имају реч primer праћену тачно једним бројем, а потом и суфиксом .txt
```

```bash
echo [[:upper:]]* #излистава све фајлове који се налазе у тренутном радном директоријуму и чији назив почиње великим словом
```

</details>

<br>

Област 7 - _Brace\_expansion_

На место означено витичастим заградама убацити више различитих вредности, дефинисаних задатим скупом/опсегом.

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
mkdir -p proba/godina_{1924..2024}/mesec_{jan,feb,mar}/nedelja_{1..4}
```

</details>


<br>

## Експанзија специјалним карактером \$

<br>

Област 7 - _Arithmetic\_expansion_

* \$((израз)) - евалуира и враћа вредност прослеђеног израза, подржане су основне математичке операције:
  * \+ - сабирање,
  * \- - одузимање,
  * \* - множење,
  * / - дељење,
  * % - остатак при дељењу,
  * \*\* - степеновање.

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
echo $(($((5**2)) * 3)) #75
```

</details>

<br>

Област 7 - _Parameter\_expansion_

* \$параметар - враћа вредност варијабле под називом параметар

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
 echo $USER # враћа ваше корисничко име
```

</details>

<br>

Област 7 - _Command\_substitution_

* \$(command) - враћа резултат извршења прослеђене наредбе _command_

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
    CURRENT_DIR=$(pwd) # унутар променљиве је смештена путања до директоријума у ком се тренутно налази корисник
```

</details>

<br>


## Escape-овање специјалних карактера

<br>


Област 7 - _Quoting_

<br>

До сада је виђен велики број карактера који имају посебно значење зависно од случаја употребе; некада је неопходно ипак занемарити та специјална значењa. Такозвано Escape-овање се може постићи на више начина:
* коришћењем \ - назначава да карактер који следи не треба посматрати као специјалан,
* коришћењем " " - садржај унутар двоструких наводника се третира као регуларан стринг, односно занемарују се специјални карактери; изузеци су \\, \$, и \`,
* коришћењем ' ' - садржај унутар једноструких наводника се третира као регуларан стринг, односно занемарују се сви специјални карактери.

<br>

<details markdown='block'>
<summary>Примери </summary>

```bash
mkdir Moj Direktorijum
```

```bash
mkdir Moj\ Direktorijum
```

```bash
mkdir "Moj Direktorijum"
```

```bash
mkdir 'Moj Direktorijum'
```

<br>

```bash
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
```

```bash
echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
```

```bash
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
```

</details>


## Регуларни изрази

<br>

Област 19 - _Regular\_Expressions_

<br>

Превасходно се користе за манипулациjу текстуалног садржаjа, и интегрисани су у
функциjу _grep_, коjа се користи за претрагу садржаjа фаjлова. Могуће jе регуларне
изразе користити и за претрагу путања до фаjлова, у комбинациjи са
функциjом _find_.

* . - мења било који карактер,
* ^ и \$ - форсирају да се уклапање у образац дефинисан изразом налази на почетку, односно крају линије, респективно,
* [скуп] - мења било који карактер који припада задатом скупу, скуп може бити кориснички дефинисан, или постојећи, односно предефинисан,
* [^скуп] - мења било који карактер који **не** припада скупу.

<br>

<details markdown='block'>
<summary>Примери </summary>

```bash
grep -i '^..j.r$' /usr/share/dict/words # за хипотетичке укрштенице, тражи речи садржане у речнику, такве да имају 5 слова, од којих је познато треће слово Ј, и последње слово Р.
```
<br>

```bash
mkdir -p vezbanje/tes{t,T}
ls ./vezbanje/ > proba.txt
grep '[A-Z]$' proba.txt 
find ./vezbanje/ -type d -regex '.*[A-Z]$'
# ово тражи директоријуме чији се назив завршава великим словом
# уочити да је за позив функције find неопходно експлицитно нагласити да се употребљава регуларни израз
# уједно је код find функције неопходно уклопити цео string у регуларни израз, а не само произвољни подстринг
# уочити да find враћа читаву путању до жељеног фајла
```

</details>


<br>

Постоји додатан сет специјалних карактера, али се посматра као надоградња претходно поменутих. За коришћење функције _grep_ у комбинацији са овим карактерима потребно је додати заставицу -E (или алтернативно позвати функцију _egrep_). Није потребно додатно модификовати позив функције _find_ у комбинацији са регуларним изразима за употребу ових карактера.


* | - алтернација између више регуларних израза; слично као и [ ], тражи се поклапање са једном од жељених опција, али се не ради о сингуларном карактеру, већ о читавом (под)стрингу,
* ? - означава да је претходни карактер опциони, дакле може се појавити 0 или 1 пут,
* \* - поново, означава да је претходни карактер опциони, али може се појавити 0 или **више** пута,
* \+ - означава претходни карактер као обавезни, односно може се појавити 1 или више пута,
* {#} - користи се да се специфицира егзактан број појављивања претходног карактера:
  * {n} - претходни карактер се појављује **тачно n** пута,
  * {n,m} -  претходни карактер се појављује најмање n, а не више од m пута,
  * {n,} - претходни карактер се појављује n или више пута,
  * {,m} - претходни карактер се појављује највише m пута.

<br>

<details markdown='block'>
<summary>Примери </summary>

```bash
echo "(555) 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
echo "555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
echo "5555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
# заграде код "позивног" броја су опционе, он је састојан из тачно 3 цифре, што је праћено са још 3 цифре, -, и на крају још 4 цифре
```
<br>

```bash
echo "AAA" | grep -E 'AAA|BBB'
echo "BBB" | grep -E 'AAA|BBB'
echo "CCC" | grep -E 'AAA|BBB'
```
<br>

```bash
mkdir -p vezbanje/test_{1..6}
ls ./vezbanje/ > proba.txt
grep -E '(test_1|test_3|test_5)' proba.txt 
```
</details>

<br>


<br>


<br>


## Скриптовање

<br>

### Гранање

<br>

Област 27 - _Branching\_with\_if_

Синтакса за употребу гранања:

<br>

```bash
    if uslov1; then
        block
        of
        commands
    elif uslov2; then
        block
        of
        commands
    else
        block
        of
        commands
    fi # не заборавити ово за затварање!
```

<br>


Поменути услови се евалуирају конверзијом у **True** или **False**; имплицитно се врши позив команде test.

<br>

```bash
test expression
#или
[ expression ]


# конкретно пример провере једнакости вредности променљиве X и целобројне вредности 5
if [ "$x" -eq 5 ]; then ...
```

<br>

Тестови који се извршавају над фајловима:
* -e : проверава да ли фајл постоји,
* -d : проверава да ли фајл постоји **И** да ли се ради о директоријуму ,
* -f : проверава да ли фајл постоји **И** да ли се ради о регуларном фајлу,
* -r, -w, -x : проверава да ли фајл постоји **И** да ли корисник има привилегију за читање, писање, извршавање, респективно;
* -s  : проверава да ли фајл постоји **И** да ли није празан (да ли му је дужина већа од 0).

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# test-file: Evaluate the status of a file
FILE=~/.bashrc
if [ -e "$FILE" ]; then
    if [ -f "$FILE" ]; then
    echo "$FILE is a regular file."
    fi
    if [ -d "$FILE" ]; then
    echo "$FILE is a directory."
    fi
    if [ -r "$FILE" ]; then
    echo "$FILE is readable."
    fi
    if [ -w "$FILE" ]; then
    echo "$FILE is writable."
    fi
    if [ -x "$FILE" ]; then
    echo "$FILE is executable/searchable."
    fi
else
    echo "$FILE does not exist"
    exit 1
fi
exit
```

</details>

<br>

Тестови који се извршавају над стринговима:
* -n string : проверава да ли стринг није празан (дужина му је већа од 0),
* -z string : проверава да ли је стринг празан (дужина му је 0),
* s1 == s2 : проверава једнакост два стринга,
* s1 != s2: проверава **не**једнакост два стринга.

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# test-string: evaluate the value of a string
ANSWER=maybe
if [ -z "$ANSWER" ]; then
    echo "There is no answer." >&2
    exit 1
fi
if [ "$ANSWER" = "yes" ]; then
    echo "The answer is YES."
elif [ "$ANSWER" = "no" ]; then
    echo "The answer is NO."
elif [ "$ANSWER" = "maybe" ]; then
    echo "The answer is MAYBE."
else
    echo "The answer is UNKNOWN."
fi
```

</details>

<br>

Тестови који се извршавају над целобројним вредностима:
* int1 -eq int2 - проверава да ли су два цела броја једнака,
* int1 -ne int2 - проверава неједнакост два цела броја,
* int1 -le int2 - проверава да ли је први цео број мањи или једнак другом,
* int1 -lt int2 - проверава да ли је први број мањи од другог,
* int1 -ge int2 - проверава да ли је први цео број већи или једнак другом,
* int1 -gt int2 - проверава да ли је први број већи од другог.

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# test-integer: evaluate the value of an integer.
INT=-5
if [ -z "$INT" ]; then
    echo "INT is empty." >&2
    exit 1
fi
if [ "$INT" -eq 0 ]; then
    echo "INT is zero."
else
    if [ "$INT" -lt 0 ]; then
        echo "INT is negative."
    else
        echo "INT is positive."
    fi
    if [ $((INT % 2)) -eq 0 ]; then
        echo "INT is even."
    else
        echo "INT is odd."
    fi
fi
```
</details>

<br>

Постоје две модификације функције test, једна за рад конкретно са целобројним вредностима, као и екстензија која дозвољава проверу стрингова употребом регуларних израза:

```bash
(( expression )) # за рад са бројевима
#и
[[ expression ]] # проширење које подржава регуларне изразе
```

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# test-integer2a: evaluate the value of an integer.
INT=-5
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then #- као предзнак је опцион, и праћен је низом цифара
    if ((INT == 0)); then #уочити да се вредности променљивих унутар (()) директно евалуирају без употребе $
        echo "INT is zero."
    else
        if ((INT < 0)); then
            echo "INT is negative."
        else
            echo "INT is positive."
        fi
        if (( ((INT % 2)) == 0)); then
            echo "INT is even."
        else
            echo "INT is odd."
        fi
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
```
</details>

<br>

Могуће је комбиновати резултате евалуације услова коришћењем следећих оператора:
* AND - логичко **И**, унутар test ([ ]) команде дефинише се заставицом -a, док се унутар проширења ( [[ ]], (( )) ) означава са &&, 
* OR - логичко **ИЛИ**, унутар test ([ ]) команде дефинише се заставицом -o, док се унутар проширења ( [[ ]], (( )) ) означава са ||,
* NOT - логичко **НЕ**, означава се са !.

<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# test-integer3: determine if an integer is within a
# specified range of values.
MIN_VAL=1
MAX_VAL=100
INT=50
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [[ "$INT" -ge "$MIN_VAL" && "$INT" -le "$MAX_VAL" ]]; then
#   if [ "$INT" -ge "$MIN_VAL" -a "$INT" -le "$MAX_VAL" ]; then         алтернативно
#   if (( ((INT >= MIN_VAL)) && ((INT <= MAX_VAL)) )); then             алтернативно
        echo "$INT is within $MIN_VAL to $MAX_VAL."
    else
        echo "$INT is out of range."
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
```
</details>

<br>

Уједно се у оквиру области 27 налази секција о операторима контроле тока - други начин за гранање.
Конкретно, за овај вид гранања се користе оператори **AND** и **OR**:
* command1 && command2 - извршава се команда command1; а потом се дешава извршавање command2 акко (ако и само ако) је извршавање command1 било **успешно**,
* command1 || command2 - извршава се команда command1; а потом се дешава извршавање command2 акко (ако и само ако) је извршавање command1 било **неуспешно**.
  
Могуће је произвољно много команди спрегнути помоћу поменутих команди.

<br>

<details markdown='block'>
<summary>Примери</summary>

```bash
 mkdir temp && cd temp #идеја је да се направи нови директоријум, а потом и да се у њега пређе
 # прво се извршава команда креирања новог директоријума
 # прелазак у нови директоријум ће се десити акко је успешно направљен поменути директоријум
```
<br>

```bash
[[ -d temp ]] || mkdir temp #идеја је проверити да ли већ постоји директоријум који је потребно креирати
#прво се извршава провера
#креирање директоријума ће се десити акко се провера да ли он већ постоји евалуира као False
```
<br>

```bash
[[ -d $NEW_DIR ]] && echo $NEW_DIR already exists, aborting && exit
mkdir $NEW_DIR
# прво се извршава провера постојања директоријума са истим називом као онај који треба креирати
# уколико такав директоријум НЕ постоји, даље наведене команде (у десно) се не извршавају, односно прелази се на нови ред
# уколико такав директоријум заиста постоји, извршава се следећа команда (еcho)
# уколико се позив echo команде успешно изврши, извршава се и команда exit
```
</details>

<br>

<br>

### Switch - case

<br>

Конструкција switch-case подразумева тражење поклапања вредности неке променљиве са једним од понуђених калупа(образаца). Користи се сет специјалних карактера описан у [првом поглављу](#манипулација-називима-фајлова). Синтакса је следећег облика:

```bash
case "@rec" in
    obrazac1) block
              of
              commands
              ;; #& опционо
    obrazac2) block
              of
              commands
              ;; #& опционо
      .
      .
      .
    obrazacN) block
              of
              commands
              ;; #& опционо
    *)  echo "Лош унос!" 
        exit 1
esac #затварање case-а!
```
* Идеја је да се вредност променљиве **rec** уклопи у 1 од дефинисаних образаца, и онда се изврши одговарајући блок команди.
* Подразумевано се провера зауставља при првом успешном поклапању. 
* Могуће је навести структуру да настави даље провере употребом специјалног карактера **&** (за случај да је очекивано, и потребно да се вредност променљиве реч уклапа у више од 1 обрасца).
* Добра је пракса поставити за последњи у низу образаца **\*)** ради хватања изузетака, односно поитенцијалних грешака.

<br>

<details markdown='block'>
<summary>Примери</summary>

```bash
#!/bin/bash
rec="Nekakva_rec"
case "$rec" in
    [[:alpha:]])
    echo "rec se sastoji iz tacno jednog slovnog karaktera." ;;
    [ABC][0-9])
    echo "rec se sastoji iz A ili B ili C, praceno cifrom." ;;
    ???)
    echo "rec se sastoji od 3 karaktera" ;;
    *.txt)
    echo "rec se zavrsava '.txt'" ;;
    *)
    echo "rec je nesto drugo." ;;
esac
```

<br>

```bash
#!/bin/bash
karakter="A"
case "$karakter" in
    [[:upper:]])
    echo "'$karakter' je veliko slovo." ;;&
    [[:lower:]])
    echo "'$karakter' je malo slovo." ;;&
    [[:alpha:]])
    echo "'$karakter' je slovo." ;;&
    [[:digit:]])
    echo "'$karakter' je cifra." ;;&
    [[:space:]])
    echo "'$karakter' je space." ;;&
esac
```
</details>

<br>

<br>

### Кориснички унос

<br>

Два приступа - тражење корисничког уноса унутар саме скрипте, или употреба позиционих параметара дефинисаних при позиву скрипте (Област 32).

<br>

* Функција _read_, пандан функцији _input()_ у Пајтону:
    ```bash
    read unos #у променљиву унос се уписује вредност са стандардног улаза
    ```
* Позициони параметри се дефинишу при позиву скрипте:
    ```bash
    ./skripta.sh parametar1 parametar2 parametarN
    ```
    Приступ и манипулација параметрима унутар скрипте се извршава помоћу пар специјалних променљивих/команди:
    * \$0 - резервисан за назив скрипте која је покренута, на нулти позициони параметар не утише позив _shift_ функције,
    * \$(1-9) - \$ праћен редним бројем (позицијом) параметра приступа вредности прослеђених параметара при позиву скрипте (1,2,...,9). За приступ параметру на позицији већој од 9 користити \${n}, нпр. \${100},
    * \$# - број прослеђених позиционих параметара при позиву скрипте (не укључујући 0-ти, резервисани параметар),
    * \$@ - акумулирање свих прослеђених параметара у један низ,
    * shift - помера све параметре, односно мења им позицију за 1 (иницијално други параметар постаје први, иницијално трећи параметар постаје други, ...).
<br>

<details markdown='block'>
<summary>Пример</summary>

```bash
#!/bin/bash
# pp.sh: script to view command line parameters
echo "
Number of arguments: $#
\$0 = $0
\$1 = $1
\$2 = $2
\$3 = $3
\$4 = $4
\$5 = $5
\$6 = $6
\$7 = $7
\$8 = $8
\$9 = $9
"
shift

echo "
After shift
Number of arguments: $#
\$0 = $0
\$1 = $1
\$2 = $2
\$3 = $3
\$4 = $4
\$5 = $5
\$6 = $6
\$7 = $7
\$8 = $8
\$9 = $9
"

```
<br>

```bash
./pp.sh a b c d


Number of arguments: 4
$0 = ./pp.sh
$1 = a
$2 = b
$3 = c
$4 = d
$5 = 
$6 = 
$7 = 
$8 = 
$9 = 


After shift
Number of arguments: 3
$0 = ./pp.sh
$1 = b
$2 = c
$3 = d
$4 = 
$5 = 
$6 = 
$7 = 
$8 = 
$9 = 
```
</details>

<br>

### For петља

<br>

Област 33 - _Looping\_with\_if_

Синтакса за употребу *for* петље:

<br>

```bash
for i in iterable; do
#for i in $@: do          рецимо
#for i; do                исто као ово изнад, ако се не наведе експлицитно по чему се итерира, подразумевају се позициони параметри
    block
    of
    commands
done #не заборавити ово за затварање!


#или, aко сте користили већ C

for (( i=0; i<5; i=i+1 )); do
    echo $i #нпр само прост бројач
done

```
