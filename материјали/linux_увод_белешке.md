# ПРА: Увод у Linux - белешке са вежби

<br>

Садржаји су углавном преузети из књиге [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1), биће назначено о којој се области ради.

<br>

## Графички кориснички интерфејс

<br>

Код Linux оперативних система је присутна релативно изражена подела на два подсистема:
* позадински део у којем је спакована логика и функционалности самог система,
* графички кориснички интерфејс (GUI) путем којег корисник може интуитивније да управља рачунаром.

Могуће је преузети и алтернирати између више опција тзв. *Desktop Enviroment*-a, који одређују како изгледа графички интерфејс вашег система.
На вежбама се користи дистрибуција *Kubuntu* (у позадини је *Ubuntu*, а изабрано је *KDE* Desktop окружење). 

Све функционалности које има кориснички интерфејс су засноване на пречицама мапираним на најчешће коришћене наредбе (команде). Исти ефекат се може постићи коришћењем *shell*-a, односно кроз комуникацију са системом путем терминала. 
Иако је могуће функционалности из GUI-a имплементирати и кроз терминал, много је већи скуп функционалности које су доступне коришћењем терминала а не путем GUI-a. 
Поента је схватити да су графички интерфејси значајно узанпредовали и да дозвољавају кориснику релативно ефикасну и интуитивну навигацију кроз систем; међутим свакако, и данас, велики део моћи оперативног система лежи у командној линији (терминалу).



## Shell

Области 1 и 8 [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1).

*Shell* у основи јесте програм који узима наредбе које корисник уноси са тастатуре и прослеђује их оперативном систему на извршење. Конкретно се бавимо *bash*-ом (од _**B**ourne **A**gain **SH**ell_). На *Kubuntu* систему је потребно покренути апликацију **Konsole** која емулира терминал. Када терминал очекује кориснички унос, пред корисником се налази такозвани *prompt*:

```bash
[username@host ~]$
```

*Prompt* се састоји из корисничког имена, имена машине, тренутног радног директоријума, и иза карактера \$ се очекује кориснички унос, који се по завршетку прослеђује оперативном систему на извршење. За ефикаснију употребу терминала постоји неколико корисних пречица (област 8):
* &uarr; - последња извршена наредба,
* **Tab** - механизам *(Auto)Completion* - када је могуће, *shell* ће сам допунити наредбу коју корисник уноси, уколико корисник довољно добро усмери *shell*,
* **Ctrl+l** - "чишћење" терминала,
* **Ctrl+c** - шаље захтев за прекид, односно убијање процеса који се тренутно извршава,
* **Ctrl+shift+c** и **Ctrl+shift+v** - пречице за *Copy/Paste* наредбе, респективно.


<br>


Како *Shell* "зна" шта треба да изврши? 
* Тако што тражи извршне датотеке (фајлове) на основу имена наредбе. На Windows системима су извршне датотеке окарактерисане .exe екстензијом/форматом. Код Linux-a екстензије у имену датотеке имају мању улогу, а постављањем дозволе за извршавање се систему сугерише да је одређену датотеку могуће извршавати као програм (о дозволама више погледати [испод](#корисничке-дозволе)). 

<br>

Где *Shell* тражи датотеке које треба да изврши као програме? 
* Потребно је навести путању до извршне датотеке како би могла бити извршена.
  
<br>

Шта су путање и какве све путање постоје на Linux системима?
* Датотечни систем је организован у хијерархијску структуру директоријума. Практично, сви директоријуми и датотеке у оквиру система су расподељени у структуру стабла, с тим да се врховни директоријум назива корени (односно *root*). Корени директоријум може садржати датотеке и поддиректоријуме, а његови поддиректоријуми могу садржати још датотека и још поддиректоријума,... Стабло датотечног система може бити произвољне дубине. Занимљиво је да за Linux датотечне системе постоји једно стабло које обухвата све уређаје (дискови, флешеви, итд.), док Windows имплементира засебна стабла за сваки уређај. Такође, треба имати у виду да **постоји разлика између малих и великих слова**!
* Путање у основи представљају смернице за навигацију кроз стабло датотечног система. 
  * Апсолутна путања подразумева полазак од кореног директоријума.
  * Релативна путања подразумева полазак од тренутног радног директоријума.
  
<br>

Како то да за већину основних наредби није потребно наводити путање до извршних датотека?
* *Shell* претражује све путање које се налазе унутар PATH променљиве, и зато је могуће извршавање великог броја наредби без да се при сваком позиву наводи путања до њих. Наравно, поред подразумеваних путања, могуће је додати кориснички дефинисане путање у поменуту PATH променљиву.

```bash
export PATH=$PATH:/путања/до/новог/директоријума/са/извршним/датотекама
```
<br>

У наставку су издвојене најчешће употребљене наредбе. Користан је и следећи [брзи подсетник за Linux наредбе](https://www.guru99.com/linux-commands-cheat-sheet.html). За већину наредби је писано детаљно корисничко упутство које се може видети употребом наредбе ```man``` са наредбом од интереса као аргументом (нпр. ```man cd``` даје детаљно упутство за коришћење ```cd``` наредбе), или алтернативно, скраћено корисничко упутство се може добити позивом наредбе од интереса уз флег ```--help``` (нпр. ```cd --help``` даје скраћено упутство за коришћење ```cd``` наредбе).

Област 2 [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1).

### Наредбе за навигацију

<br>

* ```cd /путања/до/жељеног/директоријума``` - користи се за промену тренутног радног директоријума.
  *  ```cd -``` - пребацивање у претходни радни директоријум,
  *  ```cd ..```  - пребацивање у родитељски директоријум тренутног радног директоријума,
  *  ```cd``` или ```cd ~```  - пребацивање у *home* директоријум корисника (/home/\<корисничко_име\>/).
* ```pwd``` - излистава тренутни радни директоријум (*print working directory*).  
* ```ls``` - излистава датотеке и поддиректоријуме унутар директоријума.


<br>

### Друге основне наредбе

<br>

* ```cp датотека_1 датотека_2 ... датотека_n /путања/до/одредишног/директоријума/``` - користи се за копирање датотека, дакле идентичне датотеке ће се налазити и на постојећој и на одредишној путањи,
  * ```mv датотека_1 датотека_2 ... датотека_n /путања/до/одредишног/директоријума/``` - користи се за премештање датотека, дакле датотеке ће се налазити само на одредишној путањи, не и на тренутној,
  * ```mv датотека_1 нови_назив_датотеке``` - користи се промену имена датотека, пошто не постоји наредба која је писана конкретно за ту примену.
* ```clear``` - "чишћење" терминала,
* ```touch назив_датотеке``` - иако у основи има другачију функционалност (проверити са ```touch --help``` која је тачно функционалност у питању!), обично се користи за прављење нових (празних) датотека,
  * ```rm назив_датотеке``` - користи се за уклањање тј. брисање датотека (брисање **је перманентно!**). 
* ```mkdir назив_директоријума``` - користи се за прављење новог директоријума,
  * ```rmdir назив_директоријума``` - користи се за брисање постојећег директоријума, мора бити празан (у супротном употребити ```rm -r```). 
* ```man назив_наредбе``` - излистава корисничко упутство за употребу наредбе.
* ```echo садржај``` - исписује прослеђени садржај у терминалу (стандардни излаз).
* ```cat датотека_1 датотека_2 ... датотека_n``` - користи се за надовезивање (конкатенацију) садржаја датотека, који се даље исписује у терминалу, односно прослеђује на стандардни излаз. 
* ```sudo назив_наредбе``` - извршавање наредбе као **суперкорисник (superuser)**, запамтите: *With great power comes great responsibility*!
* ```ln [-s] назив_датотеке назив_линка``` - прављење линка ка одређеној датотеци или директоријуму (Област 4 [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1) - _Create Links_). На тај начин је могуће имати датотеку (или директоријум) референцирану преко више имена и/или јој приступити са различитих локација у датотечном систему.
  *  ```ln назив_датотеке назив_линка``` - прављење чврстог (*hard*) линка. Има два ограничења: не може референцирати директоријуме и не може референцирати датотеке ван свог датотечног система тј. са других партиција или дискова.
  *  ```ln -s назив_датотеке_или_директоријума назив_линка``` - прављење симболичког линка - **напреднији начин**. Превазилази ограничења чврстих (*hard*) линкова. Функционише на исти начин као Windows пречица (*shortcut*), мада је старији од ове Windows функције много година. Направљени симболички линкови се идентификују водећим карактером `l` у атрибутима датотеке/директоријума, као нпр:
  <br> ```lrwxrwxrwx 1 user user 6 2026-01-15 22:38 датотека-сим-линк -> ../датотека``` 
  <br> где датотека `датотека-сим-линк` представља симболички линк ка датотеци `датотека` из родитељског директоријума.

<br>

### Повезивање програма

<br>

Област 6 [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1).

<br>

* `>` - преусмерава садржај са стандардног излаза у датотеку.
    
    ```bash
    echo "Здраво!" > датотека.txt
    ```
* `>>` - преусмерава садржај са стандардног излаза у датотеку, али у случају да датотека већ постоји, садржај се додаје на крај датотеке.

    ```bash
    echo "Здраво" > датотека.txt
    echo "свима!" >> датотека.txt
    ```
* `<` - преусмерава садржај датотеке на улаз програма, уместо стандардног улаза

    ```bash
    cat < датотека.txt
    # cat команда подразумевано ради са стандардним улазом, уколико јој нису прослеђена имена датотека као аргументи
    ```
* `|` - такозвани цевовод (pipe), користи се да преусмери излаз једне наредбе (уместо на стандардни излаз) на улаз друге наредбе (уместо подразумеваног стандардног улаза)

    ```bash
    ls -l /usr/bin | head -n 5
    ```
  * излаз наредбе за излиставање садржаја директоријума прослеђен је наредби која у општем случају има за задатак да издвоји првих n линија прослеђеног садржаја (наредба ```head``` искоришћена уз опцију ```-n```).


<br>

### Корисничке дозволе

<br>

Област 9 [TLCL](https://deac-ams.dl.sourceforge.net/project/linuxcommand/TLCL/24.11/TLCL-24.11.pdf?viasf=1).

<br>

Linux је развијан као систем са више корисника. Свака датотека (и директоријум) на систему има свој режим (**mod**), на основу којег се разликују приступне дозволе за различите кориснике система. Корисно је погледати [упутство](https://www.tutorialspoint.com/unix/unix-file-permission.htm).

```bash
touch тест.txt
mkdir Тест
ls -l
```
Очекивано је да се на стандардном излазу добије испис налик следећем:
```bash
drwxr-xr-x 2 owner group 4096 Nov 12 15:56 Тест
-rw-r--r-- 1 owner group    0 Nov 12 15:56 тест.txt
```
Првих 10 карактера се односе на атрибуте датотеке/директоријума. Конкретно први говори да ли се ради о регуларној датотеци (-), или пак о директоријуму (d). 

У наредних 9 карактера налазе се три триплета са дозволама које над датотеком/директоријумом имају редом власник (owner), потом власничка група корисника (group), а затим и сви остали корисници на систему (others). 

Сваки триплет се састоји од атрибута **r,w,x** (уколико постоје одговарајуће дозволе, у супротном се исписује -).

<br>

* r (read)
  * дозвољено је отворити и читати датотеку,
  * дозвољено је да се излиста садржај директоријума (под условом да је постављен и **x** атрибут). 
* w (write)
  * дозвољено је променити садржај датотеке (али није дозвољено и њено брисање, или промена назива),
  * дозвољено је да се унутар директоријума направе нове датотеке, или пак бришу (или преименују) постојеће (такође под условом да је постављен и **x** атрибут).
* x (execute)
  * дозвољено је посматрати датотеку као програм (извршну датотеку), и извршити исту,
  * дозвољено је приступити, односно ући у директоријум (рецимо позивом наредбе ```cd```). 

<br>

За промену режима (**mod**-а) датотеке или директоријума користи се наредба ```chmod```. 
* Могуће је користити окталну репрезентацију, на пример:
    ```bash
    chmod 777 тест.txt
    # сви су добили све дозволе, односно у сва 3 триплета су сва 3 атрибута постављени на 1.
    ```
* Алтернативно, могуће је радити појединачну доделу:
    ```bash
    chmod u+x,g-w,o=r Тест
    # u - скраћено од user, односи се на власника, додат му је атрибут за извршавање
    # g - скраћено од group, односи се на власничку групу корисника, одузет јој је атрибут за писање
    # o - скраћено од others, односи се на преостале кориснике, дозвољено им је само читање, независно од претходних дозвола
    ```

<br>

Треба поменути и наредбу ```chown``` која се користи за промену власника и/или власничке групе датотеке/директоријума:
```bash
chown new_user:new_group датотека.txt # поставља new_user корисника за власника датотеке датотека.txt, као и new_group за власничку групу корисника
```

<br>

#### Специјалне дозволе (демонстрација)

<br>

<details markdown='block'>
<summary>SETUID BIT </summary>

Претпоставимо да у тренутном радном директоријуму постоји датотека ```write_to_file.c``` са [кодом у ```C``` програмском језику](write_to_file.c). Улога кода је упис текста ```"Строго дефинисан садржај датотеке <назив_датотеке>."``` у датотеку чији назив корисник упише након покретања програма. Потребно је компајлирати код коришћењем ```gcc``` компајлера са привилегијама суперкорисника чиме се направи бинарна извршна датотека чији је власник ```root```, и то на следећи начин:

```bash
$ sudo gcc write_to_file.c -o write_to_file
```

Поменута бинарна датотека се назива ```write_to_file``` и након компајлирања се налази у тренутном радном директоријуму:

```bash
$ ls -l write_to_file
-rwxr-xr-x 1 root  root  15816 Dec 26 17:47 write_to_file
```

Сада је потребно креирати две празне датотеке, једну као обичан корисник (у овом случају је то тренутно пријављени корисник ```user```), а другу као суперкорисник (```root```):

```bash
$ touch датотека_1.txt
$ sudo touch датотека_2.txt
```

тако да је резултат ```ls -l``` наредбе над новонаправљеним датотекама следећи:

```bash
$ ls -l датотека_1.txt датотека_2.txt
-rw-r--r-- 1 user  user      0 Dec 26 18:55 датотека_1.txt
-rw-r--r-- 1 root  root      0 Dec 26 18:55 датотека_2.txt
```

Ако сада тренутни корисник ```user``` покрене програм ```write_to_file``` у тренутном радном директоријуму:

```bash
$ ./write_to_file
```

програм избацује упит (prompt) ```"Унесите назив датотеке: "``` где је потребно уписати ```датотека_1.txt``` и притиснути ENTER, након чега програм обавештава корисника да је садржај успешно уписан у датотеку ```датотека_1.txt```. Садржај се може проверити командом ```cat```:

```bash
$ cat датотека_1.txt
Строго дефинисан садржај датотеке датотека_1.txt.
```

Одавде закључујемо да је обичан корисник (```user```) покренуо програм ```write_to_file``` чији је власник ```root``` јер има извршне дозволе над истим, и да је на тај начин могао уписати неки тачно одређен садржај у датотеку ```датотека_1.txt```, јер је власник датотеке он сам тј. корисник ```user```. Корисник ```user``` је такође у могућности да упише и било који произвољан садржај у ```датотека_1.txt```:

```bash
$ echo "Неки произвољан садржај." >> датотека_1.txt
$ cat датотека_1.txt
Строго дефинисан садржај датотеке датотека_1.txt.
Неки произвољан садржај.
```

Ако сада ```user``` покуша уписати садржај у датотеку ```датотека_2.txt```, тако што покрене ```write_to_file``` програм и унесе ```датотека_2.txt``` у упиту за назив датотеке, добија се следећи испис:

```bash
$ ./write_to_file
Унесите назив датотеке: датотека_2.txt
Није могуће отворити датотеку за упис: Permission denied
```

односно  ```user``` нема дозволу уписа у датотеку ```датотека_2.txt``` јер она представља власништво ```root``` корисника.

Претпоставимо сада да ```root``` корисник жели омогућити ```user``` кориснику упис садржаја предефинисаног програмом ```write_to_file``` у ```датотека_2.txt```, без да му дозволи упис произвољног текста у ```датотека_2.txt```. У том случају решење је поставити ```setuid bit``` над извршном датотеком ```write_to_file``` на следећи начин:

```bash
$ sudo chmod u+s write_to_file
```

Позивом ```ls -l``` наредбе над ```write_to_file``` датотеком, видећемо да је ознака "x" за извршну дозволу власника датотеке промењена у ознаку "s", што значи да над је над датотеком ```write_to_file``` постављен ```setuid bit```:

```bash
$ ls -l write_to_file
-rwsr-xr-x 1 root root 15816 Dec 26 17:47 write_to_file
```

Уколико након тога ```user``` покуша уписати садржај у датотеку ```датотека_2.txt```, тако што покрене ```write_to_file``` програм и унесе ```датотека_2.txt``` у упиту за назив датотеке, биће му омогућен упис:

```bash
$ ./write_to_file
Унесите назив датотеке: датотека_2.txt
Садржај је успешно уписан у датотеку датотека_2.txt.

$ cat датотека_2.txt
Строго дефинисан садржај датотеке датотека_2.txt.
```

Међутим, корисник ```user``` и даље неће бити у могућности да упише произвољан садржај у ```датотека_2.txt```:

```bash
$ echo "Неки произвољан садржај." >> датотека_2.txt
bash: датотека_2.txt: Permission denied
```

Тиме је омогућено кориснику ```user``` да приступа ресурсима (у овом случају ```датотека_2.txt```) чији је власник неки други корисник (у овом случају ```root```), али само на начин предефинисан програмом ```write_to_file```, чији је власник такође (супер)корисник ```root```.

</details>

<br>

<details markdown='block'>
<summary>SETGID BIT </summary>

Потребно је у тренутном радном директоријуму одрадити следеће:
1. Пријавити се као суперкорисник (```root```) коришћењем наредбе ```su``` 
2. Направити групу ```project```
3. Направити нове кориснике ```user1``` и ```user2``` и додати их у групу ```project```
4. Новонаправљеним корисницима подесити лозинке за пријаву по жељи коришћењем наредбе ```passwd```
5. Направити директоријум ```Тест```
6. Променити власничку групу директоријума ```Тест``` на ```project```
7. Свим корисницима који су у власничкој групи директоријума ```Тест``` дати дозволу за упис у директоријум
8. Одјавити се са налога суперкорисника коришћењем наредбе ```exit```: 

```bash
$ sudo su -
## Префикс "#" следећих наредби означава да је корисник пријављен као суперкорисник root
# groupadd project
# useradd -G project user1 
# useradd -G project user2
# passwd user1
# passwd user2
# mkdir Тест
# ls -ld Тест
drwxr-xr-x 2 root root 4096 Dec 26 22:18 Тест
# chgrp project Тест
# ls -ld Тест
drwxr-xr-x 2 root project 4096 Dec 26 22:18 Тест
# chmod g+w Тест
# ls -ld Тест
drwxrwxr-x 2 root project 4096 Dec 26 22:18 Тест
# exit
```

Сада се потребно пријавити као корисник ```user1``` и направити датотеку у директоријуму ```Тест``` и групи подставити дозволу за упис у исту (ако већ подразумевано није постављена):

```bash
$ su user1
[user1]$ cd Тест
[user1]$ touch тест.txt
[user1]$ ls -l тест.txt
-rw-r--r-- 1 user1 user1 0 Dec 26 22:44 тест.txt
[user1]$ chmod g+w тест.txt
[user1]$ ls -l тест.txt
-rw-rw-r-- 1 user1 user1 0 Dec 26 22:44 тест.txt
[user1]$ exit
```

Ако корисник ```user2``` покуша да упише нешто у ```тест.txt``` који је направио ```user1``` (што је очекиван сценарио јер су оба корисника у групи ```project```, која је уједно и власничка група директоријума у коме раде оба корисника), неће му бити дозвољено јер је власничка група датотеке ```тест.txt``` постављена на ```user1```, уместо на ```project```, те група ```project``` нема никаква права над датотеком:

```bash
$ su user2
[user2]$ echo "Текст који додаје корисник user2." >> тест.txt
bash: тест.txt: Permission denied
[user2]$ exit
```

Како би све новонаправљене датотеке у директоријуму ```Тест``` подразумевано имале постављену власничку групу директоријума ```Тест``` (у овом случају групу ```project```), потребно је над директоријумом ```Тест``` поставити ```setgid bit``` на следећи начин:

```bash
$ cd ..
$ sudo chmod g+s Тест
$ ls -ld Тест
drwxrwsr-x 2 root project 4096 Dec 26 22:18 Тест
```

Видимо да је ознака "x" за извршну дозволу власничке групе директоријума промењена у ознаку "s", што значи да је над директоријумом ```Тест``` подешен ```setgid bit```.

Сада је потребно да се пријави корисник ```user1``` и направи датотеку у директоријуму ```Тест``` и групи постави дозволу за упис у исту:

```bash
$ su user1
[user1]$ cd Тест
[user1]$ touch тест.txt
[user1]$ chmod g+w тест.txt
[user1]$ ls -l тест.txt
-rw-rw-r-- 1 user1 project 0 Dec 26 22:55 тест.txt
[user1]$ exit
```

Ако се након тога пријави корисник ```user2``` и покуша уписати неки текст у датотеку ```тест.txt``` коју је претходно направио корисник ```user1```, то ће проћи јер су оба корисника у групи ```project``` која је сада уједно и власничка група датотеке ```тест.txt```:

```bash
$ su user2
[user2]$ echo "Текст који додаје корисник user2." >> тест.txt
[user2]$ cat тест.txt
Текст који додаје корисник user2.
[user2]$ exit
```

P.S. Подешавање ```umask 0002``` (обично је подразумевено 0002 или 0022) обезбеђује да новонаправљене датотеке аутоматски добију групну дозволу за упис (важи за текућу ```shell``` сесију, осим ако није трајно подешено у конфигурационим датотекама):

```bash
$ umask 0002
```

</details>

<br>

<details markdown='block'>
<summary>STICKY BIT </summary>

Потребно је у тренутном радном директоријуму као суперкорисник (```root```) урадити следеће:
1. Направити **нови** директоријум ```Тест```.
2. Свим корисницима дати дозволу за упис у директоријум ```Тест```.
3. Прећи у директоријум ```Тест``` и направити једну празну датотеку.

```bash
$ sudo mkdir Тест
$ ls -ld Тест
drwxr-xr-x 2 root root 4096 Dec 26 23:40 Тест
$ sudo chmod a+w Тест
$ ls -ld Тест
drwxrwxrwx 2 root root 4096 Dec 26 23:40 Тест
$ cd Тест
$ sudo touch тест.txt
$ ls -l тест.txt
-rw-r--r-- 1 root root 0 Dec 26 23:42 тест.txt
```

Види се да је власник новонаправљене датотеке суперкорисник (```root```). Ако сада исту датотеку покуша обрисати обичан корисник (```user```), он ће у томе успети (без обзира што је суперкорисник власник и директоријума и датотеке), јер су и осталим корисницима на систему (others) претходно дате све дозволе на нивоу директоријума ```Тест```:

```bash
$ rm тест.txt
$ ls -l тест.txt
ls: cannot access 'тест.txt': No such file or directory
```

Међутим, често се дешава да је и у том случају пожељно да датотеке не може обрисати или преименовати корисник који није власник директоријума, власник датотеке или суперкорисник. Да би се то постигло у овом случају, потребно је поставити ```sticky bit``` над директоријумом ```Тест``` (```sticky bit``` нема утицај на дозволе за читање и упис):

```bash
$ cd ..
$ sudo chmod +t Тест
$ ls -ld Тест
drwxrwxrwt 2 root root 4096 Dec 26 23:43 Тест
```

Видимо да је ознака "x" за извршну дозволу за остале кориснике система промењена у ознаку "t", што значи да је над директоријумом ```Тест``` постављен ```sticky bit```.

Ако сада суперкорисник пређе у директоријум ```Тест``` и направи једну празну датотеку:

```bash
$ cd Тест
$ sudo touch тест.txt
$ ls -l тест.txt
-rw-r--r-- 1 root root 0 Dec 26 23:56 тест.txt
```

Ако сада обичан корисник покуша обрисати датотеку ```тест.txt```, неће му бити дозвољено јер је сада над директоријумом ```Тест``` постављен ```sticky bit```:

```bash
$ rm тест.txt
rm: cannot remove 'тест.txt': Operation not permitted
```

P.S. Типичан пример подразумеване употребе ```sticky bit-а``` је над системским директоријумом ```/tmp```:

```bash
$ ls -ld /tmp
drwxrwxrwt 13 root root 400 Dec 27 00:00 /tmp
```

</details>
