# ПРА: вежбе - linux - увод - белешке

<br>

Садржаји су углавном преузети из књиге [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1), биће назначено о којој се области ради.

<br>

## Графички кориснички интерфејс

<br>

Код Linux оперативних система је присутна релативно изражена подела на два подсистема:
* позадински део у којем је спакована логика и функционалности самог система,
* графички кориснички интерфејс (GUI) путем којег корисник може интуитивније да реагује са рачунаром.

Могуће је преузети и алтернирати између више опција тзв. *Desktop Enviroment*-a, који одређују како изгледа графички интерфејс вашег система.
На вежбама се користи дистрибуција *Kubuntu* (у позадини је *Ubuntu*, а изабрано је *KDE* Desktop окружење). 

Све функционалности које има кориснички интерфејс су засноване на пречицама мапираним на најчешће коришћене команде. Исти ефекат се може постићи коришћењем *shell*-a, односно кроз комуникацију са системом путем терминала. 
Иако је могуће функционалности из GUI-a имплементирати и кроз терминал, много је већи скуп функционалности које су доступне коришћењем терминала а не путем GUI-a. 
Поента је схватити да су графички интерфејси значајно узанпредовали и да дозвољавају кориснику релативно ефикасну и интуитивну навигацију кроз систем; међутим свакако, и данас, велики део моћи оперативног система лежи у командној линији.



## Shell

Области 1 и 8 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

*Shell* у основи јесте програм који узима команде које корисник уноси са тастатуре и прослеђује их оперативном систему на извршење. Конкретно се бавимо *bash*-ом (од _**B**ourne **A**gain **SH**ell_). На *Kubuntu* систему је потребно покренути апликацију **Konsole** која емулира терминал. Када терминал очекује кориснички унос, пред корисником се налази такозвани *prompt*:

```bash
[username@host ~]$
```

*Prompt* се састоји из корисничког имена, имена машине, тренутног радног директоријума, и иза карактера \$ се очекује кориснички унос, који се по завршетку прослеђује оперативном систему на извршење. За ефикаснију употребу терминала постоји неколико корисних пречица (област 8):
* &uarr; - последња извршена команда,
* **Tab** - механизам *(Auto)Completion*, када је могуће, *shell* ће сам допунити команду коју корисник уноси, уколико корисник довољно добро усмери *shell*,
* **Ctrl+l** - "чишћење" терминала,
* **Ctrl+c** - шаље захтев за прекид, односно убијање процеса који се тренутно извршава,
* **Ctrl+shift+c** и **Ctrl+shift+v** - пречице за *Copy/Paste* команде, респективно.


<br>


Како *Shell* "зна" шта треба да изврши? 
* Тако што тражи извршне фајлове на основу имена команде. На Windows системима су извршни фајлови окарактерисани .exe екстензијом/форматом. Код Linux-a екстензије имају мању улогу, подешавањем привилегије за извршавање се систему сугерише да је дати фајл могуће извршавати као програм (о привилегијама више погледати [доле](#корисничке-привилегије)). 

<br>

Где *Shell* тражи фајлове које треба да изврши као програме? 
* Потребно је навести путању до извршног фајла како би он могао бити извршен.
  
<br>

Шта су путање и какве све путање постоје на Linux системима?
* Фајл систем је организован у хијерархијску структуру директоријума. Практично, сви директоријуми и фајлови у оквиру система су расподељени у структуру стабла, с тим да се врховни директоријум назива корени (односно *root*). Корени директоријум може садржати фајлове и поддиректоријуме, а његови поддиректоријуми могу садржати још фајлова и још поддиректоријума,... Стабло фајл система може бити произвољне дубине. Занимљиво је да за Linux фајлсистеме постоји једно стабло које обухвата све уређаје, док Windows имплементира засебна стабла за сваки уређај (дискови, флешеви, итд). Такође, треба имати у виду да **постоји разлика између малих и великих слова**!
* Путање у основи представљају смернице за навигацију кроз стабло фајл система. 
  * Апсолутна путања подразумева полазак од кореног директоријума.
  * Релативна путања подразумева полазак од тренутног радног директоријума.
  * [Пример](путање.pdf)
  
<br>

Како то да за већину основних команди није потребно наводити путање до извршних фајлова?
* *Shell* претражује све путање које се налазе унутар \$PATH варијабле, и зато је могуће извршавање великог броја команди без да се при сваком позиву наводи путања до њих. Наравно, поред подразумеваних путања, могуће је додати кориснички дефинисане путање у поменуту варијаблу.

```bash
export PATH=$PATH:/path/to/your/executables/
```
<br>

У наставку су издвојене најчешће употребљене команде. Погледати [туторијал](https://www.guru99.com/linux-commands-cheat-sheet.html). За већину команди је писано корисничко упутство (команда ```man```), или алтернативно, можете позвати функцију уз флег ```--help```.

Област 2 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

### Команде за навигацију

<br>

* ```cd path/to/next/directory``` - користи се за промену тренутног радног директоријума.
  *  ```cd -``` - пребацује у претходни радни директоријум,
  *  ```cd ..```  - пребацује се у родитељски директоријум тренутног радног директоријума,
  *  ```cd``` или ```cd ~```  - пребацује се у *home* директоријум корисника (/home/\<username\>/).
* ```pwd``` - излистава тренутни радни директоријум (*print working directory*).  
* ```ls``` - излистава фајлове и поддиректоријуме унутар директоријума.


<br>

### Друге базичне команде

<br>

* ```cp file_1 file_2 ... file_n /new/destination/path/``` - користи се за копирање фајлова, дакле идентични фајлови ће се налазити и на постојећој и на новој путањи,
  * ```mv file_1 file_2 ... file_n /new/destination/path/``` - користи се за премештање фајлова, дакле фајлови ће се налазити само на новој путањи, не и на постојећој,
  * ```mv file_1 new_filename``` - користи се промену имена фајлова, пошто не постоји функција која је писала конкретно и екпслицитно с том применом на уму.
* ```clear``` - "чишћење" терминала,
* ```touch file_name``` - иако у основи има другачију функционалност, користи се за креирање нових (празних) фајлова,
  * ```rm file_name``` - користи се за уклањање фајлова (брисање **је перманентно!**). 
* ```mkdir dir_name``` - користи се за креирање новог директоријума,
  * ```rmdir dir_name``` - користи се за брисање постојећег директоријума, мора бити празан (у супротном употребити ```rm -r```). 
* ```man command_name``` - излистава корисничко упутство за употребу команде.
* ```echo sadrzaj``` - исписује прослеђени садржај у терминалу (стандардни излаз).
* ```cat file_1 file_2 ... file_n``` - користи се за конкатенацију садржаја фајлова, који се даље исписује у терминалу, односно прослеђује на стандардни излаз. 
* ```sudo command``` - извршавање команде као **superuser**, запамтите: *With great power comes great responsibility*!


<br>

### Повезивање програма

<br>

Област 6 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

<br>

* \>  - преусмерава садржај са стандардног излаза у фајл.
    
    ```bash
    echo "Hello" > file.txt
    ```
* \>\> - преусмерава садржај са стандардног излаза у фајл, али у случају да фајл већ постоји, садржај се додаје на крај фајла.

    ```bash
    echo "Hello" > file.txt
    echo "world" >> file.txt
    ```
* \< - преусмерава садржај на улаз програма, уместо стандардног улаза

    ```bash
    cat < file.txt
    # cat команда подразумевано ради са стандардним улазом, у колико јој нису прослеђени фајлови као параметри
    ```
* \| - такозвани пајп, користи се да преусмери излаз једне команде (уместо на стандардни излаз) на улаз друге команде (уместо подразумеваног стандардног улаза)

    ```bash
    ls -l /usr/bin | head -n 5
    ```
  * излаз команде за излиставање садржаја директоријума прослеђен је функцији која има за задатак да издвоји првих n линија тока карактера (команда head искоришћена уз опцију ```-n```).


<br>

### Корисничке привилегије

<br>

Област 9 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

<br>

Linux је развијан као систем са више корисника. Сваки фајл (и директоријум) на систему има свој **mod**, на основу ког се разликују дозвољене акције за различите кориснике ситема. Погледати [туторијал](http://www.tutorialspoint.com/unix/unix-file-permission.htm).

```bash
touch test.txt
mkdir Test
ls -l
```
Очекивано је да на терминалу добијете нешто налик следећем садржају:
```bash
drwxr-xr-x 2 owner group 4096 Nov 12 15:56 Test
-rw-r--r-- 1 owner group    0 Nov 12 15:56 test.txt
```
Првих 10 карактера се односе на атрибуте фајла. Конкретно први говори да ли се ради о регуларном фајлу (-), или пак о директоријуму (d). 

У наредних 9 карактера налазе се три триплета са привилегијама које се односе на права која имају редом власник фајла (owner), потом група корисника којој припада фајл (group), а затим и сви остали корисници (other). 

Сваки триплет се састоји од атрибута **r,w,x** (уколико постоје одговарајуће привилегије, у супротном се излистава -).

<br>

* r (read)
  * дозвољено је отворити и читати фајл,
  * дозвољено је да се излиста садржај директоријума (под условом да је сетован и **x** атрибут). 
* w (write)
  * дозвољено је променити садржај фајла (али не и његово брисање, или промена назива),
  * дозвољено је да се унутар директоријума креирају нови фајлови, или пак бришу (или промени назив) постојећи (такође под условом да је сетован и **x** атрибут).
* x (execute)
  * дозвољено је третирати фајл као програм (извршни фајл), и извршити га,
  * дозвољено је приступити, односно ући у директоријум (рецимо позивом команде ```cd```). 

<br>

За промену **mod**-а фајла користи се команда ```chmod```. 
* Могуће је користити окталну репрезентацију, на пример:
    ```bash
    chmod 777 test.txt
    # сви су добили све привилегије, односно у сва 3 триплета су сва 3 атрибута постављени на 1.
    ```
* Алтернативно, могуће је радити појединачну доделу:
    ```bash
    chmod u+x,g-w,o=r Test
    # u - скраћено од user, односи се на власника фајла, додат му је атрибут за извршавање
    # g - скраћено од group, односи се на групу корисника којој припада фајл, одузет јој је атрибут за писање
    # o - скраћено од others, односи се на преостале кориснике, дозвољено им је само читање, независно од претходних привилегија
    ```

<br>

Треба поменути и команду ```chown``` која се користи за промену власника/власничке групе фајла:
```bash
chown new_user:new_group file # поставља new_user-a за власника фајла file, као и new_group за власничку групу корисника
```

<br>

#### Специјалне дозволе (демонстрација)

<br>

<details markdown='block'>
<summary>SETUID BIT </summary>

Претпоставимо да у тренутном радном директоријуму постоји датотека ```write_to_file.c``` са [кодом у ```C``` програмском језику](write_to_file.c). Улога кода је упис текста ```"Strogo definisan sadržaj datoteke <ime_datoteke>."``` у датотеку чији назив корисник упише након покретања програма. Потребно је компајлирати код коришћењем ```gcc``` компајлера са привилегијама суперкорисника чиме се креира бинарна извршна датотека чији је власник ```root```, и то на следећи начин:

```bash
$ sudo gcc write_to_file.c -o write_to_file
```

Поменута бинарна датотека се назива ```write_to_file``` и након компајлирања се налази у тренутном радном директоријуму:

```bash
$ ls -l write_to_file
-rwxr-xr-x 1 root  root  15816 Dec 26 17:47 write_to_file
```

Сада је потребно креирати две празне датотеке, једну као обичан корисник (у овом случају је то тренутно пријављени корисник ```user```), а другу као суперкорисник (```root```):

```bash
$ touch file1.txt
$ sudo touch file2.txt
```

тако да је резултат ```ls -l``` команде над креираним датотекама следећи:

```bash
$ ls -l file1.txt file2.txt
-rw-r--r-- 1 user  user      0 Dec 26 18:55 file1.txt
-rw-r--r-- 1 root  root      0 Dec 26 18:55 file2.txt
```

Ако сада корисник ```user``` покрене програм ```write_to_file``` у тренутном радном директоријуму:

```bash
$ ./write_to_file
```

програм избацује промпт ```"Unesite naziv datoteke: "``` где се прво упише ```file1.txt``` и притисне ENTER, након чега програм обавештава корисника да је садржај успешно уписан у датотеку ```file1.txt```. Садржај се може проверити командом ```cat```:

```bash
$ cat file1.txt
Strogo definisan sadržaj datoteke file1.txt.
```

Одавде закључујемо да је обичан корисник (```user```) покренуо програм ```write_to_file``` чији је власник ```root``` јер има извршне привилегије над истим, и да је на тај начин могао уписати неки тачно одређен садржај у датотеку ```file1.txt```, јер је власник датотеке он сам тј. корисник ```user```. Корисник ```user``` је такође у могућности да упише и било који произвољан садржај у ```file1.txt```:

```bash
$ echo "Neki proizvoljan sadržaj." >> file1.txt
$ cat file1.txt
Strogo definisan sadržaj datoteke file1.txt.
Neki proizvoljan sadržaj.
```

Ако сада ```user``` покуша уписати садржај у датотеку ```file2.txt``` (односно покрене ```write_to_file``` програм и унесе ```file2.txt``` у промпту за назив датотеке) добија се следећи испис:

```bash
./write_to_file
Unesite naziv datoteke: file2.txt
Nije moguće otvoriti datoteku za upis: Permission denied
```

односно  ```user``` нема дозволу уписа у датотеку ```file2.txt``` јер она представља власништво ```root``` корисника.

Замислите сада да ```root``` корисник жели омогућити ```user``` кориснику упис садржаја предефинисаног програмом ```write_to_file``` у ```file2.txt```, али без да му омогући привилегије уписа произвољног текста у ```file2.txt```. У том случају решење је поставити ```setuid bit``` над извршном датотеком ```write_to_file``` на следећи начин:

```bash
$ sudo chmod u+s write_to_file
```

Позивом ```ls -l``` команде над ```write_to_file``` датотеком, видећемо да је ознака "x" за извршну дозволу власника датотеке промењена у ознаку "s", што значи да над је над датотеком ```write_to_file``` подешен ```setuid bit```:

```bash
$ ls -l write_to_file
-rwsr-xr-x 1 root root 15816 Dec 26 17:47 write_to_file
```

Уколико након тога ```user``` покуша уписати садржај у датотеку ```file2.txt``` (односно покрене ```write_to_file``` програм и унесе ```file2.txt``` у промпту за назив датотеке), биће му омогућен упис:

```bash
$ ./write_to_file
Unesite naziv datoteke: file2.txt
Sadržaj je uspešno upisan u datoteku file2.txt.

$ cat file2.txt
Strogo definisan sadržaj datoteke file2.txt.
```

Међутим, корисник ```user``` и даље неће бити у могућности да упише произвољан садржај у ```file2.txt```:

```bash
$ echo "Neki proizvoljan sadržaj." >> file2.txt
bash: file2.txt: Permission denied
```

Тиме је омогућено кориснику ```user``` да приступа ресурсима (у овом случају ```file2.txt```) чији је власник неки други корисник (у овом случају ```root```), али само на начин предефинисан програмом ```write_to_file```, чији је власник такође (супер)корисник ```root```.

</details>

<br>

<details markdown='block'>
<summary>SETGID BIT </summary>

Потребно је у тренутном радном директоријуму као суперкорисник (```root```) одрадити следеће:
1. Направити групу ```project```
2. Додати кориснике ```user1``` и ```user2``` у групу ```project``` (корисници ```user1``` и ```user2``` ће морати да се излогују и поново улогују да би промене важиле)
3. Направити директоријум ```dir```
4. Променити власничку групу директоријума ```dir``` на ```project```
5. Свим корисницима који су у власничкој групи директоријума ```dir``` дати дозволу за упис у директоријум:

```bash
$ sudo groupadd project
$ sudo usermod -aG project user1
$ sudo usermod -aG project user2
$ sudo mkdir dir
$ ls -ld dir
drwxr-xr-x 2 root root 4096 Dec 26 22:18 dir
$ sudo chgrp project dir
$ ls -ld dir
drwxr-xr-x 2 root project 4096 Dec 26 22:18 dir
$ sudo chmod g+w dir
$ ls -ld dir
drwxrwxr-x 2 root project 4096 Dec 26 22:18 dir
```

Рецимо да корисник ```user1``` направи датотеку у директоријуму ```dir``` и групи подеси дозволу за упис у исту:

```bash
[user1]$ cd dir
[user1]$ touch file1.txt
[user1]$ chmod g+w file1.txt
[user1]$ ls -l file1.txt
-rw-rw-r-- 1 user1 user1 0 Dec 26 22:44 file1.txt
```

Ако корисник ```user2``` покуша да упише нешто у ```file1.txt``` који је направио ```user1``` (што је очекиван сценарио јер су оба корисника у групи ```project```, која је уједно и власничка група директоријума у коме раде оба корисника), неће му бити дозвољено јер је власничка група датотеке ```file1.txt``` подешена на ```user1```, уместо на ```project```, те група ```project``` нема никаква права над датотеком:

```bash
[user2]$ echo "Tekst koji dodaje user2." >> file1.txt
bash: file1.txt: Permission denied
```

Како би све новонаправљене датотеке у директоријуму ```dir``` подразумевано имале подешену власничку групу директоријума ```dir``` (у обом случају групу ```project```), потребно је над директоријумом ```dir``` подесити ```setgid bit``` на следећи начин:

```bash
$ cd ..
$ sudo chmod g+s dir
$ ls -ld dir
drwxrwsr-x 2 root project 4096 Dec 26 22:18 dir
```

Видимо да је ознака "x" за извршну дозволу власничке групе директоријума промењена у ознаку "s", што значи да је над директоријумом ```dir``` подешен ```setgid bit```.

Сада је потребно да се улогује корисник ```user1``` и направи датотеку у директоријуму ```dir``` и групи подеси дозволу за упис у исту:

```bash
[user1]$ cd dir
[user1]$ touch file1.txt
[user1]$ chmod g+w file1.txt
[user1]$ ls -l file1.txt
-rw-rw-r-- 1 user1 project 0 Dec 26 22:55 file1.txt
```

Ако се након тога улогује корисник ```user2``` и покуша уписати неки текст у датотеку ```file1.txt``` коју је претходно направио корисник ```user1```, то ће проћи јер су оба корисника у групи ```project``` која је сада уједно и власничка група датотеке ```file1.txt```:

```bash
[user2]$ echo "Tekst koji dodaje user2." >> file1.txt
[user2]$ cat file1.txt
Tekst koji dodaje user2.
```

P.S. Подешавање ```umask 0002``` (обично је подразумевено 0002 или 0022) обезбеђује да новонаправљене датотеке аутоматски добију групну дозволу за упис (важи за текућу ```shell``` сесију, осим ако није трајно подешено у конфигурационим датотекама):

```bash
$ umask 0002
```

</details>

<br>

<details markdown='block'>
<summary>STICKY BIT </summary>

Потребно је у тренутном радном директоријуму као суперкорисник (```root```) одрадити следеће:
1. Направити директоријум ```dir```
2. Свим корисницима дати дозволу за упис у директоријум
3. Прећи у директоријум ```dir``` и направити једну празну датотеку

```bash
$ sudo mkdir dir
$ ls -ld dir
drwxr-xr-x 2 root root 4096 Dec 26 23:40 dir
$ sudo chmod a+w dir
$ ls -ld dir
drwxrwxrwx 2 root root 4096 Dec 26 23:40 dir
$ cd dir
$ sudo touch file1.txt
$ ls -l file1.txt
-rw-r--r-- 1 root root 0 Dec 26 23:42 file1.txt
```

Видимо да је власник новонаправљене датотеке суперкорисник (```root```). Ако сада исту датотеку покуша обрисати обичан корисник (```user```), он ће у томе успети (без обзира што је суперкорисник власник и директоријума и датотеке), јер су свима дате све дозволе на нивоу директоријума ```dir```:

```bash
$ rm file1.txt
$ ls -l file1.txt
ls: cannot access 'file1.txt': No such file or directory
```

Међутим, често се дешава да је и у том случају пожељно да датотеке не може обрисати или преименовати корисник који није власник директоријума, власник датотеке или суперкорисник. Да би се то постигло потребно је подесити ```sticky bit``` над директоријумом ```dir``` (```sticky bit``` нема утицај на дозволе за читање и упис):

```bash
$ cd ..
$ sudo chmod +t dir
$ ls -ld dir
drwxrwxrwt 2 root root 4096 Dec 26 23:43 dir
```

Видимо да је ознака "x" за извршну дозволу за остале кориснике промењена у ознаку "t", што значи да је над директоријумом ```dir``` подешен ```sticky bit```.

Ако сада суперкорисник пређе у директоријум ```dir``` и направи једну празну датотеку:

```bash
$ cd dir
$ sudo touch file1.txt
$ ls -l file1.txt
-rw-r--r-- 1 root root 0 Dec 26 23:56 file1.txt
```

и ако сада обичан корисник покуша обрисати датотеку ```file1.txt```, неће му бити дозвољено јер је сада над директоријумом ```dir``` подешен ```sticky bit```:

```bash
$ rm file1.txt
rm: cannot remove 'file1.txt': Operation not permitted
```

P.S. Типичан пример подразумеване употребе ```sticky bit-а``` је над системским директоријумом ```/tmp```:

```bash
$ ls -ld /tmp
drwxrwxrwt 13 root root 400 Dec 27 00:00 /tmp
```

</details>
