# ПРА: вежбе - linux - увод - белешке

<br>

Садржаји су углавном преузети из књиге [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1), биће назначено о којој се области ради.

<br>

## Графички кориснички интерфејс

<br>

Код Linux оперативних система је присутна релативно изражена подела на два подсистема:
* позадински део у којем је спакована логика и функционалности самог система,
* графички кориснички интерфејс (GUI) путем којег корисник може интуитивније да реагује са рачунаром.

Могуће је преузети и алтернирати између више опција тзв. *Desktop Enviroment*-a, који одређују како изгледа графички интерфејс вашег система.
На вежбама се користи дистрибуција *Kubuntu* (у позадини је *Ubuntu*, а изабрано је *KDE* Desktop окружење). 

Све функционалности које има кориснички интерфејс су засноване на пречицама мапираним на најчешће коришћене команде. Исти ефекат се може постићи коришћењем *shell*-a, односно кроз комуникацију са системом путем терминала. 
Иако је могуће функционалности из GUI-a имплементирати и кроз терминал, много је већи скуп функционалности које су доступне коришћењем терминала а не путем GUI-a. 
Поента је схватити да су графички интерфејси значајно узанпредовали и да дозвољавају кориснику релативно ефикасну и интуитивну навигацију кроз систем; међутим свакако, и данас, велики део моћи оперативног система лежи у командној линији.



## Shell

Области 1 и 8 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

*Shell* у основи јесте програм који узима команде које корисник уноси са тастатуре и прослеђује их оперативном систему на извршење. Конкретно се бавимо *bash*-ом (од _**B**ourne **A**gain **SH**ell_). На *Kubuntu* систему је потребно покренути апликацију **Konsole** која емулира терминал. Када терминал очекује кориснички унос, пред корисником се налази такозвани *prompt*:

```bash
[username@host ~]$
```

*Prompt* се састоји из корисничког имена, имена машине, тренутног радног директоријума, и иза карактера \$ се очекује кориснички унос, који се по завршетку прослеђује оперативном систему на извршење. За ефикаснију употребу терминала постоји неколико корисних пречица (област 8):
* &uarr; - последња извршена команда,
* **Tab** - механизам *(Auto)Completion*, када је могуће, *shell* ће сам допунити команду коју корисник уноси, уколико корисник довољно добро усмери *shell*,
* **Ctrl+l** - "чишћење" терминала,
* **Ctrl+c** - шаље захтев за прекид, односно убијање процеса који се тренутно извршава,
* **Ctrl+shift+c** и **Ctrl+shift+v** - пречице за *Copy/Paste* команде, респективно.


<br>


Како *Shell* "зна" шта треба да изврши? 
* Тако што тражи извршне фајлове на основу имена команде. На Windows системима су извршни фајлови окарактерисани .exe екстензијом/форматом. Код Linux-a екстензије имају мању улогу, подешавањем привилегије за извршавање се систему сугерише да је дати фајл могуће извршавати као програм (о привилегијама више погледати [доле](#корисничке-привилегије)). 

<br>

Где *Shell* тражи фајлове које треба да изврши као програме? 
* Потребно је навести путању до извршног фајла како би он могао бити извршен.
  
<br>

Шта су путање и какве све путање постоје на Linux системима?
* Фајл систем је организован у хијерархијску структуру директоријума. Практично, сви директоријуми и фајлови у оквиру система су расподељени у структуру стабла, с тим да се врховни директоријум назива корени (односно *root*). Корени директоријум може садржати фајлове и поддиректоријуме, а његови поддиректоријуми могу садржати још фајлова и још поддиректоријума,... Стабло фајл система може бити произвољне дубине. Занимљиво је да за Linux фајлсистеме постоји једно стабло које обухвата све уређаје, док Windows имплементира засебна стабла за сваки уређај (дискови, флешеви, итд). Такође, треба имати у виду да **постоји разлика између малих и великих слова**!
* Путање у основи представљају смернице за навигацију кроз стабло фајл система. 
  * Апсолутна путања подразумева полазак од кореног директоријума.
  * Релативна путања подразумева полазак од тренутног радног директоријума.
  * [Пример](путање.pdf)
  
<br>

Како то да за већину основних команди није потребно наводити путање до извршних фајлова?
* *Shell* претражује све путање које се налазе унутар \$PATH варијабле, и зато је могуће извршавање великог броја команди без да се при сваком позиву наводи путања до њих. Наравно, поред подразумеваних путања, могуће је додати кориснички дефинисане путање у поменуту варијаблу.

```bash
export PATH=$PATH:/path/to/your/executables/
```
<br>

У наставку су издвојене најчешће употребљене команде. Погледати [туторијал](https://www.guru99.com/linux-commands-cheat-sheet.html). За већину команди је писано корисничко упутство (команда ```man```), или алтернативно, можете позвати функцију уз флег ```--help```.

Област 2 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

### Команде за навигацију

<br>

* ```cd path/to/next/directory``` - користи се за промену тренутног радног директоријума.
  *  ```cd -``` - пребацује у претходни радни директоријум,
  *  ```cd ..```  - пребацује се у родитељски директоријум тренутног радног директоријума,
  *  ```cd``` или ```cd ~```  - пребацује се у *home* директоријум корисника (/home/\<username\>/).
* ```pwd``` - излистава тренутни радни директоријум (*print working directory*).  
* ```ls``` - излистава фајлове и поддиректоријуме унутар директоријума.


<br>

### Друге базичне команде

<br>

* ```cp file_1 file_2 ... file_n /new/destination/path/``` - користи се за копирање фајлова, дакле идентични фајлови ће се налазити и на постојећој и на новој путањи,
  * ```mv file_1 file_2 ... file_n /new/destination/path/``` - користи се за премештање фајлова, дакле фајлови ће се налазити само на новој путањи, не и на постојећој,
  * ```mv file_1 new_filename``` - користи се промену имена фајлова, пошто не постоји функција која је писала конкретно и екпслицитно с том применом на уму.
* ```clear``` - "чишћење" терминала,
* ```touch file_name``` - иако у основи има другачију функционалност, користи се за креирање нових (празних) фајлова,
  * ```rm file_name``` - користи се за уклањање фајлова (брисање **је перманентно!**). 
* ```mkdir dir_name``` - користи се за креирање новог директоријума,
  * ```rmdir dir_name``` - користи се за брисање постојећег директоријума, мора бити празан (у супротном употребити ```rm -r```). 
* ```man command_name``` - излистава корисничко упутство за употребу команде.
* ```echo sadrzaj``` - исписује прослеђени садржај у терминалу (стандардни излаз).
* ```cat file_1 file_2 ... file_n``` - користи се за конкатенацију садржаја фајлова, који се даље исписује у терминалу, односно прослеђује на стандардни излаз. 
* ```sudo command``` - извршавање команде као **superuser**, запамтите: *With great power comes great responsibility*!


<br>

### Повезивање програма

<br>

Област 6 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

<br>

* \>  - преусмерава садржај са стандардног излаза у фајл.
    
    ```bash
    echo "Hello" > file.txt
    ```
* \>\> - преусмерава садржај са стандардног излаза у фајл, али у случају да фајл већ постоји, садржај се додаје на крај фајла.

    ```bash
    echo "Hello" > file.txt
    echo "world" >> file.txt
    ```
* \< - преусмерава садржај на улаз програма, уместо стандардног улаза

    ```bash
    cat < file.txt
    # cat команда подразумевано ради са стандардним улазом, у колико јој нису прослеђени фајлови као параметри
    ```
* \| - такозвани пајп, користи се да преусмери излаз једне команде (уместо на стандардни излаз) на улаз друге команде (уместо подразумеваног стандардног улаза)

    ```bash
    ls -l /usr/bin | head -n 5
    ```
  * излаз команде за излиставање садржаја директоријума прослеђен је функцији која има за задатак да издвоји првих n линија тока карактера (команда head искоришћена уз опцију ```-n```).


<br>

### Корисничке привилегије

<br>

Област 9 [TLCL](https://deac-fra.dl.sourceforge.net/project/linuxcommand/TLCL/19.01/TLCL-19.01.pdf?viasf=1).

<br>

Linux је развијан као систем са више корисника. Сваки фајл (и директоријум) на систему има свој **mod**, на основу ког се разликују дозвољене акције за различите кориснике ситема. Погледати [туторијал](http://www.tutorialspoint.com/unix/unix-file-permission.htm).

```bash
touch test.txt
mkdir Test
ls -l
```
Очекивано је да на терминалу добијете нешто налик следећем садржају:
```bash
drwxr-xr-x 2 owner group 4096 Nov 12 15:56 Test
-rw-r--r-- 1 owner group    0 Nov 12 15:56 test.txt
```
Првих 10 карактера се односе на атрибуте фајла. Конкретно први говори да ли се ради о регуларном фајлу (-), или пак о директоријуму (d). 

У наредних 9 карактера налазе се три триплета са привилегијама које се односе на права која имају редом власник фајла (owner), потом група корисника којој припада фајл (group), а затим и сви остали корисници (other). 

Сваки триплет се састоји од атрибута **r,w,x** (уколико постоје одговарајуће привилегије, у супротном се излистава -).

<br>

* r (read)
  * дозвољено је отворити и читати фајл,
  * дозвољено је да се излиста садржај директоријума (под условом да је сетован и **x** атрибут). 
* w (write)
  * дозвољено је променити садржај фајла (али не и његово брисање, или промена назива),
  * дозвољено је да се унутар директоријума креирају нови фајлови, или пак бришу (или промени назив) постојећи (такође под условом да је сетован и **x** атрибут).
* x (execute)
  * дозвољено је третирати фајл као програм (извршни фајл), и извршити га,
  * дозвољено је приступити, односно ући у директоријум (рецимо позивом команде ```cd```). 

<br>

За промену **mod**-а фајла користи се команда ```chmod```. 
* Могуће је користити окталну репрезентацију, на пример:
    ```bash
    chmod 777 test.txt
    # сви су добили све привилегије, односно у сва 3 триплета су сва 3 атрибута постављени на 1.
    ```
* Алтернативно, могуће је радити појединачну доделу:
    ```bash
    chmod u+x,g-w,o=r Test
    # u - скраћено од user, односи се на власника фајла, додат му је атрибут за извршавање
    # g - скраћено од group, односи се на групу корисника којој припада фајл, одузет јој је атрибут за писање
    # o - скраћено од others, односи се на преостале кориснике, дозвољено им је само читање, независно од претходних привилегија
    ```

<br>

Треба поменути и команду ```chown``` која се користи за промену власника/власничке групе фајла:
```bash
chown new_user:new_group file # поставља new_user-a за власника фајла file, као и new_group за власничку групу корисника
```
